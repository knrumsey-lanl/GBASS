df <- theta[2]
res <- sum(dnorm(x, 0, 1/sqrt(theta[1]), log=TRUE))
res <- res + dchisq(prec, df=df, log=TRUE)
res <- res + dgamma(2, 0.1, log=TRUE)
}
x <- rt(1e6, 10)
post <- Metro_Hastings(lpost, c(1, 5), x=x)
lpost <- function(theta, x){
df <- theta[2]
prec <- theta[1]/df
res <- sum(dnorm(x, 0, 1/sqrt(theta[1]), log=TRUE))
res <- res + dchisq(prec, df=df, log=TRUE)
res <- res + dgamma(2, 0.1, log=TRUE)
}
x <- rt(1e6, 10)
post <- Metro_Hastings(lpost, c(1, 5), x=x)
x <- rt(100, 10)
post <- Metro_Hastings(lpost, c(1, 5), x=x)
ts.plot(post$trace[,1])
ts.plot(post$trace[,2])
?ff1
library(GBASS)
?ff1
n <- 100 #Number of observations
p <- 4   #Number of variables
X <- matrix(runif(n*p), nrow=n)
y <- apply(X, 1, ff1)
?ff1
ff1
GBASS::ff1
library(GBASS)
?ff1
GBASS::ff1
ff1(c(2,3))
ff2
?ff2
?gbass
?funcs
funcs
ff1
ff1
library(GBASS)
ff1
gbass
qbass
?gbass
gbass(X, y)
library(devtools)
library(roxygen2)
document()
gbass
ff1
?ff1
n <- 100 #Number of observations
p <- 4   #Number of variables
X <- matrix(runif(n*p), nrow=n)
y <- apply(X, 1, ff1)
fit <- gbass(X, y)
predict(fit, X)
?predict
ff1
gbass
qbass
predict.gbass
predict.gbass(mod)
predict.gbass(fit)
predict.gbass(fit, X)
predict(fit, X)
library(EpiModel)
library(parallel)
##############################
## get training data - 2000 model runs with 3 parameters (but only 2 active), 30 time steps
n<-2000
p<-3
nt<-21
X<-matrix(runif(n*p),ncol=p) # inputs on 0-1 scale
y<-matrix(nrow=nrow(X),ncol=nt)
#Parameter range chosen so that P(# New Infections > 0) >= 0.05
for(i in 1:n){
param <- param.icm(inf.prob = X[i,1]*.5 + .25, act.rate = X[i,2]*1 + .5) # rescale inputs...
init <- init.icm(s.num = 5000, i.num = 1) # 500 suceptible, 1 infected
control <- control.icm(type = "SI", nsims = 1, nsteps = nt) # single simulation
mod <- icm(param, init, control)
y[i,]<-unlist(mod$epi$i.num)
}
matplot(t(y),type='l')
n<-2000
p<-2
nt<-21
X<-matrix(runif(n*p),ncol=p) # inputs on 0-1 scale
y<-matrix(nrow=nrow(X),ncol=nt)
#Parameter range chosen so that P(# New Infections > 0) >= 0.05
for(i in 1:n){
param <- param.icm(inf.prob = X[i,1]*.5 + .25, act.rate = X[i,2]*1 + .5) # rescale inputs...
init <- init.icm(s.num = 5000, i.num = 1) # 500 suceptible, 1 infected
control <- control.icm(type = "SI", nsims = 1, nsteps = nt) # single simulation
mod <- icm(param, init, control)
y[i,]<-unlist(mod$epi$i.num)
}
matplot(t(y),type='l')
dim(X)
library(BASS)
library(GBASS)
gbass
library("GBASS")
gbass
GBASS:::gbass
library(GBASS)
library(GBASS)
gbass::
library(GBASS)
?ff1
ff1
dim(X)
?bass
#Fit Emulators
mod <- bass(X, y)
X
#Fit Emulators
mod <- bass(X, y)
#Fit Emulators
mod <- bass(t(X), y)
class(X)
mod(as.matrix(X), y)
bass(as.matrix(X), y)
f<-function(x){
10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
}
sigma<-1 # noise sd
n<-500 # number of observations
x<-matrix(runif(n*10),n,10) #10 variables, only first 5 matter
y<-rnorm(n,f(x),sigma)
## fit BASS, no tempering
mod<-bass(x,y)
plot(mod)
x
class(x)
class(X)
y
length(y)
## get training data - 2000 model runs with 3 parameters (but only 2 active), 30 time steps
n<-2000
p<-2
nt<-21
X<-matrix(runif(n*p),ncol=p) # inputs on 0-1 scale
y<-matrix(nrow=nrow(X),ncol=nt)
#Parameter range chosen so that P(# New Infections > 0) >= 0.05
for(i in 1:n){
param <- param.icm(inf.prob = X[i,1]*.5 + .25, act.rate = X[i,2]*1 + .5) # rescale inputs...
init <- init.icm(s.num = 5000, i.num = 1) # 500 suceptible, 1 infected
control <- control.icm(type = "SI", nsims = 1, nsteps = nt) # single simulation
mod <- icm(param, init, control)
y[i,]<-unlist(mod$epi$i.num)
}
matplot(t(y),type='l')
y
dim(y)
y <- y[,21]
dim(y)
length(y)
#Fit Emulators
mod <- bass(X, y)
library(parallel)
plot(mod)
mod_q <- mods <- mclapply(c(.25,.5,.75),
function(qq) qbass(matrix(X),
y,q=qq,
maxInt=1,
w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.03, b_lambda=.03,
nmcmc=10000, nburn=8001, thin=4),
mc.cores = 3, mc.preschedule = F)
?bass
mod_q <- mods <- mclapply(c(.25,.5,.75),
function(qq) qbass(matrix(X),
y,q=qq,
maxInt=1,
w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.03, b_lambda=.03,
nmcmc=10000, nburn=8001, thin=4),
mc.cores = 3, mc.preschedule = F)
qbass(X, y, q=0.25, maxInt=2,w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.03, b_lambda=.03,
nmcmc=10000, nburn=8001, thin=2)
mod_q <- mods <- mclapply(c(.25,.5,.75),
function(qq) qbass(matrix(X),
y,q=qq,
maxInt=2,
w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.03, b_lambda=.03,
nmcmc=10000, nburn=8001, thin=4),
mc.cores = 3, mc.preschedule = F)
mod_q <- mods <- mclapply(c(.25,.5,.75),
function(qq) qbass(X, y, q=0.25, maxInt=2,w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.03, b_lambda=.03,
nmcmc=10000, nburn=8001, thin=2),
mc.cores = 3, mc.preschedule = F)
mod_q <- mods <- mclapply(c(.25,.5,.75),
function(qq) qbass(X, y, q=qq, maxInt=2,w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.03, b_lambda=.03,
nmcmc=10000, nburn=8001, thin=2),
mc.cores = 3, mc.preschedule = F)
mod
mod_q <- mclapply(c(.25,.5,.75),
function(qq) qbass(X, y, q=qq, maxInt=2,w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.03, b_lambda=.03,
nmcmc=10000, nburn=8001, thin=2),
mc.cores = 3, mc.preschedule = F)
qbass(X, y, q=0.25, maxInt=2,w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.03, b_lambda=.03,
nmcmc=10000, nburn=8001, thin=2)
##############################
## get training data - 2000 model runs with 3 parameters (but only 2 active), 30 time steps
n<-2000
p<-2
nt<-21
X<-matrix(runif(n*p),ncol=p) # inputs on 0-1 scale
y<-matrix(nrow=nrow(X),ncol=nt)
#Parameter range chosen so that P(# New Infections > 0) >= 0.05
for(i in 1:n){
param <- param.icm(inf.prob = X[i,1]*.5 + .25, act.rate = X[i,2]*1 + .5) # rescale inputs...
init <- init.icm(s.num = 5000, i.num = 1) # 500 suceptible, 1 infected
control <- control.icm(type = "SI", nsims = 1, nsteps = nt) # single simulation
mod <- icm(param, init, control)
y[i,]<-unlist(mod$epi$i.num)
}
matplot(t(y),type='l')
y <- y[,21]
?icm
y
par(mfrow=c(1,1))
dim(y)
y
## get training data - 2000 model runs with 3 parameters (but only 2 active), 30 time steps
n<-2000
p<-2
nt<-21
X<-matrix(runif(n*p),ncol=p) # inputs on 0-1 scale
y<-matrix(nrow=nrow(X),ncol=nt)
#Parameter range chosen so that P(# New Infections > 0) >= 0.05
for(i in 1:n){
param <- param.icm(inf.prob = X[i,1]*.5 + .25, act.rate = X[i,2]*1 + .5) # rescale inputs...
init <- init.icm(s.num = 5000, i.num = 1) # 500 suceptible, 1 infected
control <- control.icm(type = "SI", nsims = 1, nsteps = nt) # single simulation
mod <- icm(param, init, control)
y[i,]<-unlist(mod$epi$i.num)
}
matplot(t(y),type='l')
dim(y)
matplot(t(y[,1:14]), type='l')
matplot(t(y[,1:21]), type='l')
21*2000
?bass
20*1000
ind <- (20*(i-1) + 1):(20*i)
ind
i
dim(X)
dim(y)
xx <- matrix(NA, nrow=40000, ncol=2)
xxf <- rep(NA, length(40000))
yy <- rep(NA, length(40000))
for(i in 1:n){
ind <- (20*(i-1) + 1):(20*i)
xx[ind,] <- X[i,]
yy[ind] <- y[i,1:20]
xxf[ind] <- 1:20
}
mod <- bass(xx, yy, xx.func=xxf)
xxf
xxf
sigma<-1 # noise sd
n<-500 # number of observations
nfunc<-50 # size of functional variable grid
xfunc<-seq(0,1,length.out=nfunc) # functional grid
x<-matrix(runif(n*9),n,9) # 9 non-functional variables, only first 4 matter
X<-cbind(rep(xfunc,each=n),kronecker(rep(1,nfunc),x))
X
class(X)
kronecker()
kronecker
?kronecker
nfunc <- 20
xfunc <- seq(0,1,length=nfunc)
dim(X)
dim(XX)
##############################
## get training data - 2000 model runs with 3 parameters (but only 2 active), 30 time steps
n<-2000
p<-2
nt<-21
X<-matrix(runif(n*p),ncol=p) # inputs on 0-1 scale
y<-matrix(nrow=nrow(X),ncol=nt)
#Parameter range chosen so that P(# New Infections > 0) >= 0.05
for(i in 1:n){
param <- param.icm(inf.prob = X[i,1]*.5 + .25, act.rate = X[i,2]*1 + .5) # rescale inputs...
init <- init.icm(s.num = 5000, i.num = 1) # 500 suceptible, 1 infected
control <- control.icm(type = "SI", nsims = 1, nsteps = nt) # single simulation
mod <- icm(param, init, control)
y[i,]<-unlist(mod$epi$i.num)
}
matplot(t(y),type='l')
dim(X)
nfunc <- 20
xfunc <- seq(0,1,length=nfunc)
#Fit Emulators
mod <- bass(X, y, xx.func=xfunc)
#Fit Emulators
mod <- bass(X, y[,1:20], xx.func=xfunc)
nfunc <- 21
xfunc <- seq(0,1,length=nfunc)
xx <- cbind(rep(x))
#Fit Emulators
mod <- bass(X, y, xx.func=xfunc)
#Format data
xx <- matrix(NA, nrow=40000, ncol=2)
xxf <- rep(NA, length(40000))
yy <- rep(NA, length(40000))
for(i in 1:n){
ind <- (20*(i-1) + 1):(20*i)
xx[ind,] <- X[i,]
yy[ind] <- y[i,1:20]
xxf[ind] <- 1:20
}
xx <- cbind(xx, xxf)
dim(xx)
#Format data for gbass
xx <- matrix(NA, nrow=40000, ncol=2)
xxf <- rep(NA, length(40000))
yy <- rep(NA, length(40000))
for(i in 1:n){
ind <- (20*(i-1) + 1):(20*i)
xx[ind,] <- X[i,]
yy[ind] <- y[i,1:20]
xxf[ind] <- 1:20
}
xx <- cbind(xx, xxf)
nfunc <- 20
xfunc <- seq(0,1,length=nfunc)
#Fit Emulators
mod <- bass(X, y[,1:20], xx.func=xfunc)
dim(xx)
?qbass
?gbass
#Qbass emulators (yikes might take a while without functional capabilities)
mod_q1 <- qbass(xx, yy, q=0.5, nmcmc=5000, nburn=4001, a_lambda=0.1, b_lambda=0.1)
dim(X)
range(X)
range(xx)
which.max(xx)
xx <- matrix(NA, nrow=40000, ncol=2)
xxf <- rep(NA, length(40000))
yy <- rep(NA, length(40000))
for(i in 1:n){
ind <- (20*(i-1) + 1):(20*i)
xx[ind,] <- X[i,]
yy[ind] <- y[i,1:20]
xxf[ind] <- seq(0, 1, length.out=20)
}
xx <- cbind(xx, xxf)
xxf
range(xx)
#Qbass emulators (yikes might take a while without functional capabilities)
mod_q1 <- qbass(xx, yy, q=0.5, nmcmc=500, nburn=401, a_lambda=0.1, b_lambda=0.1)
#Simulate calibration data
zeta <- function(x, theta){
param <- param.icm(inf.prob = theta[1]*.5 + .25, act.rate = theta[2]*1 + .5) # rescale inputs...
init <- init.icm(s.num = 5000, i.num = 1) # 500 suceptible, 1 infected
control <- control.icm(type = "SI", nsims = 1, nsteps = x) # single simulation
mod <- icm(param, init, control)
y<-unlist(mod$epi$i.num)[x]
}
zeta(14, c(0.5, 0.5))
print(zeta(14, c(0.5, 0.5)))
#Simulate calibration data
zeta <- function(x, theta){
param <- param.icm(inf.prob = theta[1]*.5 + .25, act.rate = theta[2]*1 + .5) # rescale inputs...
init <- init.icm(s.num = 5000, i.num = 1) # 500 suceptible, 1 infected
control <- control.icm(type = "SI", nsims = 1, nsteps = x) # single simulation
mod <- icm(param, init, control)
unlist(mod$epi$i.num)[x]
}
zeta(13, 0.5)
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
zeta(13, c(0.5, 0.5))
?bass
?gbass
?bass
predict(mod, c(0.5, 0.5,17/20))
predict(mod, c(0.5, 0.5))
dim(predict(mod, c(0.5, 0.5)))
matplot(t(predict(mod, c(0.5, 0.5))), type='l')
?predict.bass
seq(0, 1, length=5)
seq(0, 1, length.out=5)
seq(0, 1, length.out=7)
1/6
xx
dim(xx)
length(yy)
parallel::detectCores()
mods <- mclapply((1:5)/6,
function(qq) qbass(matrix(mcycle$x),
mcycle$accel,q=qq,
maxInt=3,
w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.1, b_lambda=.1,
nmcmc=5000, nburn=4001, thin=1),
mc.cores = 5, mc.preschedule = F)
xx
yy
mods <- mclapply((1:5)/6,
function(qq) qbass(xx,
yy, q=qq,
maxInt=3,
w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2),
a_lambda=.1, b_lambda=.1,
nmcmc=5000, nburn=4001),
mc.cores = 5, mc.preschedule = F)
mods
mods[[1]]
65/12
78/12
library(GBASS)
?ff1
n <- 100 #Number of observations
p <- 4   #Number of variables (beyond p = 2, variables are inert)
X <- matrix(runif(n*p), nrow=n)
y <- apply(X, 1, ff1)
gbass(X, y)
gbass(X, y, nmcmc=1000, nburn=9001, thin=2)
gbass(X, y, nmcmc=1000, nburn=901, thin=2)
ts.plotmod <- gbass(X, y, nmcmc=1000, nburn=901, thin=2)
ts.plot(ts.plotmod$w)
ts.plot(ts.plotmod$v)
ts.plot(ts.plotmod$tau)
ts.plot(ts.plotmod$lam)
ts.plot(ts.plotmod$M)
ts.plot(ts.plotmod$a)
ts.plot(ts.plotmod$aDrm(ts.plotmod))
rm(ts.plotmod)
ls
?build_prior
?rgig2
?gbass
?hbass
hbass
?gbass
?rmpon
n <- 10000
alpha <- 5
gamma <- 1
mu <- 2
y <- rep(NA, n)
for(i in 1:n){
y[i] <- rmpon(1, alpha, gamma, mu)
}
hist(y, breaks=30, freq=F)
c <- integrate(dmpon, lower=0, upper=20, alpha=alpha, gamma=gamma, mu=mu)$value
curve(dmpon(x, alpha, gamma, mu)/c, add=TRUE, lwd=2, col='blue')
gm <- gbass(X, y)
?ff1
n <- 100 #Number of observations
p <- 4   #Number of variables (beyond p = 2, variables are inert)
X <- matrix(runif(n*p), nrow=n)
y <- apply(X, 1, ff1)
gbass(X, y)
gm <- gbass(X, y, nmcmc=1000)
gm <- gbass(X, y, nmcmc=1000, nburn=901)
bm <- gm2bm(gm)
bm <- GBASS:::gm2bm(gm)
class(bm)
sobol(bm)
plot(sobol(bm))
tmp <- function(a, b=a/2) print(b)
tmp(10)
nw_triangle
nw_gamma_prior()
nw_gamma_prior()
nw_gamma_prior
nw_gamma_prior()
nw_gamma_prior(p1=0.5, p2=0.0001)
var(rgamma(10000, 1, .1))
y
var(y)
.1*sqrt(10)
nw_gamma_prior(p1=0.5, p2=1e-3)
nw_gamma_prior(p1=0.5, p2=1e-4)
library(devtools)
library(roxygen2)
document()
library(GBASS)
library(GBASS)
?nwbass
?gbass
?rmpon
?dmpon
2^6
2^6*3
2^4*9
